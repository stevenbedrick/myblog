--- 
layout: post
title: XPath Insanity
tags: []

status: publish
type: post
published: true
meta: {}

---
Yet another entry under the heading of "stupid stuff I figured out so that you don't have to". The other day, a fellow student in my program came to me with what seemed to be a very simple XPath problem&mdash; accessing a namespaced node. I explained to him that dealing with namespaces in XPath is pretty straightforward&mdash; you just prefix the node name or attribute name you're after with whatever prefix you assigned the namespace. E.g., if the node is described in your document as <code>foo:someNode</code>, you would simply use that in your XPath. He replied that he tried that, and that it wasn't working. We got the sample file loaded onto my computer, and a couple of minutes with Ruby and REXML determined that, in fact, that XPath <em>was</em> working. He said something to the effect of: "I'm using Java, should that matter?" I replied "Nah, XPath is XPath." Ha. Ha. Ha. He figured that he must've typed something wrong, and that he'd go back and give it another try. A little while later, he came back saying that he'd triple-checked it, and that it still wasn't working. I went down to his computer, and after several hours of cursing and re-compiling, we finally figured it out.<p />Without going into the gory details of a very long and heroic debugging story, I'll sum it up by saying this: XPath goes all wonky when your document has both a default namespace as well as other prefixed namespaces. The reasons are fantastically obscure, are rooted in the depths of a W3C spefication document, and don't seem to apply if you're using REXML and Ruby but most definitely do if you're using any Java library based on Jaxen (e.g., Dom4J or DOX). but have a sort of twisted logic to them. For a detailed description, see <a href="http://www.xml.com/lpt/a/2004/02/25/qanda.html">This article over at XML.com</a>. I'll also walk through the gist of it below.<p />Consider the following XML document describing our generic friend, Joe Smith:<p /><code><br /><div class="CodeRay">  <div class="code"><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;person&gt;  &lt;name&gt;    &lt;given&gt;Joe&lt;/given&gt;    &lt;family&gt;Smith&lt;/familiy&gt;  &lt;/name&gt;  &lt;contactInfo&gt;    &lt;phone&gt;503-555-1234&lt;/phone&gt;  &lt;/contactInfo&gt;&lt;/person&gt;</pre></div></div><br /></code><p />An appropriate XPath expression to get the DOM node containing Joe's surname would be: <code>/person/name/family</code>. Simple, nice, and easy. Let's up the ante a little bit. Let's say that you're a vampire, and this snippet of XML represents an entry in your "donor list". As a discerning gourmet, you want to encode Joe's blood type (hey, some days are AB+ kind of days, some are  more O-). Not only are you a discerning vampire, you're a properly-trained  programmer (or lazy, take your pick) as well. Luckily for you, the International Brotherhood of Vampires has a published schema for describing blood types:<p /><code><br /><div class="CodeRay">  <div class="code"><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;bloodType&gt;  &lt;type&gt;O&lt;/type&gt;  &lt;rhFactor&gt;-&lt;/rhFactor&gt;&lt;/bloodType&gt;</pre></div></div><br /></code><p />Integrating this into your schema is fairly straightforward: add <code>xmlns:vamp="http://www.ibvamps.org/Schema/blood"</code> to your <code>&lt;person&gt;</code> tag. Of course, if you add in a second namespace, you typically want to specify a default namespace to refer to your own part of the document. This is accomplished by adding <code>xmlns="http://www.mydomain.com/Schema/donorEntry</code> right before our <code>xmlns:vamp</code> declaration. Now, our entry looks like this:<p /><code><br /><div class="CodeRay">  <div class="code"><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;person xmlns=&quot;http://www.mydomain.com/Schema/donorEntry&quot;   xmlns:vamp=&quot;http://www.ibvamps.org/Schema/blood&quot;&gt;  &lt;name&gt;    &lt;given&gt;Joe&lt;/given&gt;    &lt;family&gt;Smith&lt;/familiy&gt;  &lt;/name&gt;  &lt;contactInfo&gt;    &lt;phone&gt;503-555-1234&lt;/phone&gt;  &lt;/contactInfo&gt;  &lt;vamp:bloodType&gt;    &lt;vamp:type&gt;O&lt;/vamp:type&gt;    &lt;vamp:rhFactor&gt;-&lt;/vamp:rhFactor&gt;  &lt;/vamp:bloodType&gt;&lt;/person&gt;</pre></div></div><br /></code><p />After doing this, try running the XPath expression we laid out earlier to try and get Joe's surname (<code>/person/name/family</code>). If you're using Dom4J, you'll find that it no longer returns any nodes. You'll be able to access our namespaced nodes if you use an expression like <code>/*/vamp:bloodType/vamp:type</code>, but not if you use <code>/person/vamp:bloodType/vamp:type</code>. If you ask your parser to return the document's root node, you'll get a node named <code>person</code>, which appears correct... but if you run <code>/person</code> against your document, you won't get any results. So, what gives?<p />Without going into more detail than anybody who doesn't work for the W3C cares about, node name matching is done using fully qualified node names (at least, according to the XPath spec). This means that the parser internally translates <code>vamp:type</code> to something along the lines of  <code>{http://www.ibvamps.org/Schema/blood}type</code>. This is all well and good for nodes that have a namespace prefix, but what about the nodes that fall under our default namespace? They have no <em>explicit</em> prefix, but a default namespace <em>has</em> been specified, so the parser translates to <code>{}person</code>. Therefore, if we just pass in <code>person</code>, the parser doesn't see a match. <p />The solution is either to not use a default namespace, or to use a way-to-complicated voodoo workaround involving the XPath <code>local-name()</code> function. It turns out that <code>[local-name()="Person"]</code> gets around this difficult-to-figure-out behavior, so our final XPath for determining Joe's surname becomes: <code>/*[local-name()="Person"]/*[local-name()="name"]/*[local-name()="family"]</code>, or simply <code>//*[local-name()="family"]</code>, depending on how the document is set up. I have no idea what the performance implicactions of this approach are, but, then again, I have no idea how most XPath engines perform ordinarily. Presumably, this doesn't do anything <em>too</em> awful, expecially for smaller documents. Let's just say that I wouldn't suggest trying this with your 400,000-node XML representation of SNOMED.<p />So, there you have it: the end-product of several hours of hair-pulling, reduced to a couple of paragraphs. Go forth, Google, and index this page, so that others will be spared the hours of torment that we suffered.<div class="blogger-post-footer"><img class="posterous_download_image" src="https://blogger.googleusercontent.com/tracker/13766433-113592007675135370?l=bedrickblog.blogspot.com" height="1" alt="" width="1" /></div>
